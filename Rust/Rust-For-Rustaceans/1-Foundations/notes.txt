------------------
| 1: Foundations |
------------------

---- Talking About Memory ----
- value: combination of a type and an element that is in the types domain of values
  - can be turned into a sequence of bytes using its types representation
- Ex: 6 is the the type u8, instance of mathematical integer 6, in memory rep of 0x06
- value is stored in a place (a location that can hold a value)
- pointer is a value that holds the address of a region of memory
- high level memory model useful for thinking about lifetimes and borrows
  - think of variables as names given to values as they are instantiated, moved, and used
  - consider the flows from a variable to all of its uses
- low level memory model good for reasoning about unsafe code and raw pointers
  - variables name memory locations that may or may not hold legal values
  - value slot that is filled and replaced with new values
- stack: segment of memory that your program uses as a scratch space for function calls
  - on each function call, frame allocated at the top of the stack
  - near bottom is frame for main function
  - variables stored in a frame on stack cannot be accessed after frame goes away, so after reference to 
  it must have a lifetime that is at most as long as the lifetime of the frame
- heap: pool of memory that is not tired to the current call stack of the program

---- Ownership ----
- all value have a single owner
- values may implment copy in which they are copied instead of moved

--- Borrowing and Lifetimes ----
- owner of a vlaue may lend out that vlaue to others without giving up ownership via references
- shared reference (&T) is pointer that may be shared
  - values behind shared reference are not mutalbe
  - many can exist at any point in time
- mut reference (&mut T) is a pointer to a value that may be mutated
  - compile assumes that the reference is exclusive



