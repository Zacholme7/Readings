// Notes: Compilation and Dispatch
// -----------------------------
// - when you write type/function that is generic over T, youre really telling compiler to make copy of that type/func for each type T
//   - doesnt actually do full copy past, just parts that you use
// - static dispath: for any given copy, the address we are dispatchign to is known statically
// - generic type -> many non generic types is called monomorphization
// - dynamic dispatch enables code to call a trait method on a generic type without knowing what that type is
//   - &dyn makes it so caller must give two pieces of info for that arg. the address of the pattern and the function
//   - in practice, get pointer to memory in vtable
// - combination of a type that implments a trait and its vtable is a trait object
// - to be object-safe, non of traits methods can be generic or use the self type and no static methods
// - dynamic dispatch can cut compile time and improve efficiency, but it prevents compiler from optimizing for the specific types that are used
// - broadly speaking, want to use static dispatch in libraries and dynamic dispath in binaries

// 1) monomorphization
// - helps produce much more efficient code
// - generate for any types we invoke the function with
// - leads to more code in the final binary
// 
// example 1
fn strlen(s: impl AsRef<str>) -> usize {
    s.as_ref().len()
}

// can think of the following two as being generated by the compiler due to monoporphization
fn strlen_refstr(s: &str) -> usize {
    s.len()
}

fn strlen_string(s: String) -> usize {
    s.len()
}


fn main() {
    let hello_str = "hello";
    let hello_string = String::from("hello");
    // these calls will generate the two functions that we listed above
    strlen(hello_str);
    strlen(hello_string);
}
