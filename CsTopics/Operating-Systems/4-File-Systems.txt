-------------------
| 4: File Systems | 
-------------------
- computer systems need to store and retrieve information
- requirements for long term info storage
1) Must be possible to store very large amount of info
2) Information must survive the termination of the process using it
3) Multiple processes must be able to access info at once
- File: logical units of information created by processes
  - info in files is persistent
  - managed by OS

---- Memory Notes ----
----------------------
- File: logical units of information created by processes



--------------------
---- 4.1: Files ----
--------------------

---- File Naming ----
---------------------
- a file is an abstraction mechanism to store and load info
- file name and file extension (indicates something about the file)

---- File Structure ----
------------------------
- file can be structured as byte sequence, record sequence, or as a tree
- byte sequence
  - unstructured
  - os does not know or care what is in the file, just sees the butes
  - used by unix and windows
  - provides a lot of flexibility
- record sequence      
  - sequence of fixed length records
  - read operations return one record and write operations overwrite/append one record
- tree based
  - file consists of tree of records, each contain key field in fixed position on the record
  - get the record with a specific key

---- File Types ----
--------------------
- regular files: contain user information
  - ascii/binary files
  - can easily edit
- directories: system files for maintaining structure of file system
- character special files: related to input/output
- block special files: used to model disks

---- File Access ----
---------------------
- random access files
- read operation can give position where to start reading
- seek can be used to set the current position
- can then read sequentially

---- File Attributes ----
-------------------------
- metadata describing properties of the file
  - protection, creator, time stats, ...

---- File Operations ----
- create, delete, open, close, read, write, append, seek, get attrs, set attrs, rename

---- Summary ----
- Files are a key primitive in operating systems. They are an abstraction over sequence of bytes
that provide convinent access without exposing the underlying hardware. There are various types of file
that you can create and each file has a bunch of attributes/metadata associated with it to describe important 
information about the file

--- Memory Notes ----
---------------------
- None




--------------------------
---- 4.2: Directories ----
--------------------------

---- Single level directory system ----
---------------------------------------
- one directory, root directory, containing all files
- simple and able to locate files quickly
- sufficient for very simple systems

---- Hierarchical Directory System ----
---------------------------------------
- tree of directories to group common files
- all modern file systems are organized in this manner

---- Path Names ----
--------------------
- absolute path name: all paths from root to file
- relative path name: path from working directory to file

---- Directory operations ----
------------------------------
- create, delete, opendir, closedir, readdir, rename, link, unlink


---- Summary ----
------------------
- All modern systems use a hierarchical directory system where you can arbitrarily create new 
files and directories whereever you want to group common information together

---- Memory Notes ----
----------------------
- N/A




-----------------------------------------
---- 4.3: File System Implementation ----
-----------------------------------------

---- 4.3.1: File System Layout ----
-----------------------------------
- file system stored on disks
- can divide disk into partitions w/ diff file systems on each partitions
- on older systems, the sector 0 of disk called MBR (master book record), used to boot computer
  - end of MBR contains parition table, starting/ending addrs for each parition
  - locate active partition and read in boot block, execute
  - program in book block loads os
  - superblock: contains all key parameters about file system
- next school as unified extensible firmeare interface
  - UEFI is now most popular way to boot personal computer system
  - fast booting, different architectures, disk size up to 8ZiB
  - looks for location of partition table in second block of device
  - first block is reserved as special market for software that expects MBR here
  - GPT (GUID Partition Table) contains info about location of various partitions on disk
    - contains the start and end of each parition
  - UEFI keeps backup of GPT in last block
  - firmware should support atleast FAT file system
  - EFI system partition (ESp) contains file system, boot process can use which contains programs, config files, etc 

---- 4.3.2: Implementing Files ----
-----------------------------------
- need to keep track of which disk blocks go with which file
1) Contiguous allocation
- store each file as contiguous run of disk blocks
- each file starts w/ brand new block
- simple to implement, just need disk addr of first block and num of blocks in file
- read performance is excellent, read in a single operation
- disk becomes very fragmented over time!!
  - need to compact which is way to expensive or maintain list of free spaces
2) Linked list allocation
- file is linked list of disk blocks
- first part of each block used as pointer to next one, rest of block for data
- no space is lost due to fragmentation
- random access is very slow, have to start from head and go through all prior blocks 
- storage no longer power of 2 since pointer takes up a few bytes
3) Linked-List Allocation Using a Table in memory
- can use prior approach and take pointer work from each block and put it in table in memory
- chain is terminaed with special market
- called FAT (file allocation table)
- chain still has to be followed for random access but it is in memory so it is much faster
- although, entire table must be in memory at all times 
4) I-Nodes (index node)
- lists the attributes and disk addresses of the files blocks
- given i-node, possible to find all blocks of the file
- i-node needs to be in memory only when file is open
- size proportional the maximum number of files that may be opened

---- 4.3.3: Implementing Directories ----
-----------------------------------------
- directory entry provides info needed to find disk blocks
  - map ASCII name of file onto info needed to locate the data
- two ways to structure: inline and in heap
1) Inline: file entry length, attributes, filename
2) Heap: pointer to file name, file attributes

---- 4.3.4: Shared Files ----
-----------------------------
- two solutions
1) disk blocks are not listed in directories
  - they are listed in little data structures associated with the file
  - ds could be something like an i-node
2) create a new file of type link
  - os just reads the original file













































