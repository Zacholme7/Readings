----------------------------
| 2: Processes and threads | 
----------------------------

------------------------
---- 2.1: Processes ----
------------------------
- upon system boot, many processes are started at the same time
- in multiprogramming system cpu switches from process to process very quickly
- process model
  - all runnable software on computer organized into sequential processes
  - process: instance of an executing program
  - each process has its own virtual cpu
  - multiprogramming: switching back and forth quickly between processes
  - process is activity of some kind. it has program, input, output, and state. program is something that may be stored on disk not doing anything
  - 4 key events cause processes to be created
    - System initialization
    - Execution of process creation sys call by running process
    - User request to create new process
    - Initialization of a batch job
- daemons: processes that stay in the background to handle some activity
- fork will create an exact clone of the calling process in unix
  - have same memory image, environment strings, and same open files
  - child run execve to change its memory image and run a new program
  - parent and child PROCESS have their own distinct address space
- process terminates from one of the following conditions
  - Normal exit (voluntary): finish their work 
  - Error exit (voluntary): call exit
  - Fatal error (involuntary): discover fatal error or bug
  - Killed by another process (involuntary): kill command
- processes form hierarchy, kind of like hydra
  - init process after boot in first
- three process states
  - Running (actually using the cpu at that instant)
  - Ready (runnable, temporarily stopped to let another process run)
  - Blocked (unable to run until some other external event happens)
- state changes possible
  - running -> blocked : process blocks for input
  - running -> ready: scheduler picks another process to run
  - ready -> running: scheduler picks this process
  - blocked -> ready: input becomes available
- os maintains proces table with one entry per process
  - contains important imformation about the processes state
- each I/O class has location called interrupt vector that contains address of ISR (interrupt service routine)
  - on interrupt, computer jumps to address in interrupt vector then run ISR
- cpu utilization/degree of multiprogramming = 1 - p ** n

Summary: 
Unix utilizes a process model in which all of the software eon the computer is organized into sequential processes. A process 
is simply an instance of an execution program. Eveything on the computer is a process. They can be both created and destoryed.
The cpu utilizes multiprocessing where multiple processes are all being executed by the cpu will switch between them quickly to 
give the illusion that they are all executing at the same time. A process can either be running, ready to run, or blocked. The 
os maintains a process table taht contaisn information about all the processes running on a system

Memory notes:
- Multiprogramming: multiple programs running simultaneously on one CPU, switches from process to process very quickly
- Process: instance of executing program. It has a program, input, output, and a state
- What is the process model: all runnable software organized into sequential processes
- 4 events that cause a process to be created: System initialization, execution of process creation sys call by running process,
user request to create new process, initialization of a batch job
- Daemons: process that stays in background to handle some activity
- Fork(): create exact clone of calling process. Same memory image, env, and open file. Parent and child process have distinct address 
spaces
- Process termination conditions: normal exit (voluntary): finished their work. Error exit (voluntary): call exit, Fatal error (involuntary): discover 
fatal error or bug. Killed by another process (involuntary): kill command
- 3 process running states: Running (actually being used by cpu at that instant), ready (runnable, temporarily stopped to let another process run),
blocked (unable to run until some other external event happens)
- How does os keep track of processes?: has process table with one entry per process, contains info about process state
- Interrupt vector: contains address of ISR (instruction service routine) for each I/O class. Upon interrupt, computer jump to addr in interrupt vector 
then runs the ISR


----------------------
---- 2.2: Threads ----
----------------------
- threads are basically mini processes
  - parallel entities share address space and data among themselves
  - lighter weight than processes, faster to create and destory
- concepts of a process
  - resource grouping
    - group together related resources such as addr space, open files, alarms, etc
  - execution
    - process is a thread of execution. has pc, registers, vars, stack, etc
- processes are used to group resources together, threads are the entities scheduled for execution on the cpu
- threads add to the process model by allowing multiple executions to take place in the same process environment
- multithreading: allowing multiple threads in the same process
  - cpu switches rapidly back and forth among threads
- threads share the same address space, but each have their own stack
- thread can be running, blocked, ready, terminated like a process
- threads can be implemented in user space or kernel space
- user space
  - kernel knows nothing about them and just mamanges single threaded process
  - run on top of run time system
  - each process needs own thread table to keep track of threads in that process, managed by run time system
  - thread switch very very fast
  - process can have customized scheduling algorithm
  - problems when implementing blocking calls and have to manually yield
  - still have to trap to kernel to handle system call
- in kerenel
  - dont need a run time system
  - kernel has single thread table that keeps track of all threads
    - does creation and deletion here
    - holds each threads registers, state, etc
  - cost of sys call to make thread is very high
- hybrid approach
  - use kernel level threads and multiplex user level threads onto some or all of them

Summary:
Within processes, there is the concept of threads. Threads can be thought of as mini processes. They are lightweight entitires
that are fast to create and destory that share sources among themselves. Processes are used to group resources together while threads
allow for multiple executions to take place in the same environemtn. Threads can be implemented in user space, the kernel, or a hybrid
approach. 

Memory Notes:
- Thread: a lighweight process that shares data/address space among themselves. Allow multiple executions to take place in the 
same environment. Have their own stack. 
- Multithreading: allowing multiple threads to execute in the same process
- User space thread impl: kernel is unaware of them and they run on top of a runtime system. Each process has a thread table that is managed by a 
runtime system that keeps tracks of all of the threads. Switching is very fast and can have customized scheduling but still have to manually yield
and trap to kernel for io
- Kernel thread impl: threads implemented in the kernel, dont need a runtime system and there is a single thread table that keeps track of all
running threads. higher overhead for thread switching and creation is expensive
- Hybrid thread impl: usage of kernel level threads and multiplex multiple user level threads onto them


-----------------------------------
---- 2.3: Event Driven Servers ----
-----------------------------------
- Threads: parallelism: blocking system calls
- Single threaded process: No parallelism, blocking system calls
- Finite-state machine/event-driven: parallelism, nonblocking system calls, interrupts

Summary:
An event driver architecture is an alternative to threads/single threaded process where there is an implementation
of a finite state machine taht responds to events and interacts with the os via nonblocking calls

Memory notes:
None


-------------------------------------------------------------
---- 2.4: Synchronization and Interprocess Communication ----
-------------------------------------------------------------
- Three problems with IPC
1) How to pass info 
2) How to make sure two or more process/threads to not get in each others way
3) Sequencing when dependencies are present
- Race conditions: when two or more processes are reading/writing to some shared data and the final result depends on who runs when
  - need to prohibit more than one process from reading/writing shared data at same time, mutual exclusion
- Critical section: part of program where shared memory is accessed
- proposals for mutual exclusion
1) Disabiling Interrupts
- on single processor system, just disable interrupts after entering critical section and re-enable after leaving
- means cpu will not switch processes
- unwise to give user process power to turn off interrupts
- if multiprocessor, only affts CPU that disabled it
- disabiling interrupts only useful in OS itself
2) Lock variables
- lock variable set to zero and when process wants to enter CS, test then set
- non atomic so still suffers race conditions
3) Strict Alternation
- keep track of whos turn it is via some variable
- busy waiting, continuously testing variable
- not good when one process is much slower
4)Peterson's Solution
- before using shred var, call enter_region with process num
- call leave_region to leave and signal that it is safe to enter
5) TSL Instruction
- test and set lock, read contents of memory word lock and store nonzero value at memory address
- atomic instruction
- alternative instr is XCHG, which x86 use
- requires busy waiting
- sleep: system call that causes caller to block/be suspended until another process wakes it up
- wakeup: takes process to be awakened and wakes it up
- producer-consumer/bounded buffer problem
  - producer puts stuff in buffer, consumer takes it out
  - producer go to sleep if buffer is full, consumer go to sleep if buffer is empty
  - race condition on the count variable that tracks amount of items in buffer, can screw up wakeups
  - 





Memory Notes:
- Three problems with IPC: how to pass information, how to make sure two or more processes/threads do not get in each others way,
sequencies when dependencies are present
- Race conditions: when two or more processes are reading/writing to some shared data and the final result depends on who runs when
- Critical section: part of program where shared memory is accessed
- Mutual exclusion - pros/cons of disabiling interrupts: pros: provides mutual exclusion, cons: not wise to give user this power, only 
affects single cpu
- Mutual exclusion - pros/cons of lock variables: variable that is set to zero and changed to one upon entering crit section. 
pros: none, cons: does not work as still suffers race conditions
- Mutual exclusion - pros/cons of Strict Alternation: keep track of whos turn it is via some variable. pros: provides mutual exclusion. 
cons: busy waiting wasts cpu cycles, not good when one process is much slower
- Mutual exclusion - TSL instruction: test and set lock, read contents of memory work lock and store nonzero value there, it is an atomic 
instr, it provides mutual exclusion, but it requires busy waiting
- producer-consumer problem: produer puts stuff on queue, consumer takes off, num items tracked by couter and producer/consumer put to sleep
when they cannot perform work. problem is when a wakeup call gets lost due to a race condition on the counter 






    













































