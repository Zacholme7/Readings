------------------------
| 3: Memory Management | 
------------------------
- "programs expand to fill memory available to them"
- 

------------------------------------
---- 3.1: No Memory Abstraction ----
------------------------------------
- 1980s and before every program just say entire physical memory

---- Running Multiple Programs without a memory abstraction ----
---------------------------------------------------------------- 
- have to save memory to file and bring in other program

---- Summary ----
-----------------
- Early computers didnt have any abstraction over memory and just ran
all processes in the same physical memory space.

---- Memory Notes ----
----------------------
- None




--------------------------------------------------
---- 3.2: A Memory Abstraction: Address space ----
--------------------------------------------------

---- The Notion of an address space ----
----------------------------------------
- to allow multiple application in memory, protection and relocation have to be solved
- address space: set of addresses that a process can use to address memory
  - created kind of abstract memory for programs to use
- each process has its own address space
- simple solution to address space
  - dynamic relocation
  - map each processes address space onto different part of physical memory
  - cpu has base and limit reg
  - base reg has addr of start of program, limit loaded with length of program
  - add addr loc to base reg and make sure within limit
  - disadvantage is additional comparison for each memory reference


---- Swapping ----
------------------
- total amount of RAM needed often much more than what can fit in mem
- swapping: bringing in each process, running it for a while, then moving it to nonvolatile storage
- creates holes in memory but can use memory compaction to fill in
- allocate initial program and room to grow


---- Managing Free Memory ----
------------------------------
- can use bitmaps and free lists to keep track of memory usage
1) bitmap: memory divded into allocation units in size from a few words to several kilobytes
  - each allocation unit has bit, 0 for free and 1 for occupied
  - searching bit map is slow
2) linked list: linked list of allocated and free memory segements
  - segement either process or empty hole between two processes
  - several algorithms for allocation. first fit, next fit, best fit, quick fit, ...


---- Summary ----
-----------------
- The most basic memory abstration is the concept of an address space which is just
a set of addresses that a process can use to address its memory. Each process has its own address
space, so we need to have some way to fit all of the address spaces in memory when there are multiple processes
running. There are various algorithms to achieve this but none of them presented here are optimal, but the
concept of swapping is important in the final solution


---- Memory Notes ----
----------------------
- address space: set of addresses that a process can use to address memory
- addr space swapping: bringing in each process, running it for a while, then moving it to nonvolatile storage
- mem mgmt w/ bitmap: memory divded into allocation units in size from a few words to several kilobytes, each allocation unit 
has bit, 0 for free and 1 for occupied, searching bit map is slow
- mem mgmt w/ linked list: linked list of allocated and free memory segements, segement either process or 
empty hole between two processes, several algorithms for allocation. first fit, next fit, best fit, quick fit, ...




-----------------------------
---- 3.3: Virtual Memory ----
-----------------------------
- there is a need to run programs that are too large to fit in memory
- virtual memory: program has its own addr space that is broken into pages
  - page: a contiguous range of addresses mapped onto physical memory
  - not all pages have to be present


---- Paging ----
----------------
- virtual addresses: program generated addresses that form the virtual address space
  - go to the mmu
- memory management unit: maps virtual addresses onto physical memory addresses
- virtual address space: all virtual addresses divided into pages
- pages: fixed size units of virtual addresses
- page frame: corresponding physical memory to a page
- present/absent bit keeps track of which pages are physically present in memory
- if MMU sees page is unmapped, page fault occurs
  - writes unused page to disk and brings in needed page
- page number used as index into page table, other bits used as offset
- process
1) program issue adress to access byte in page
2) mmu checks page table to see if page is mapped to physical frame
  - if mapped, retrieve data
3) if not mapped, issue page fault bc it needs to load the page into memory
4) select little used page to write to disk, then fetch needed page
5) set old page to unmapped and new page to mapped
6) restart the instruction


---- Page Tables ----
---------------------
- virtual address split into virtual page number (high order bits) and offset (low order bits)
- virtual page number used as index into page table to find entry for that virtual page
  - if found, page frame number attatched to offset to form physical address for memory
- purpose of page table it so map virtual pages onto page frames
- structure of a page table entry
  - varies but general form is consistent
  - page frame number
  - present/absent bit: indicates wherther entry is valid and can be used
  - protection: tells what kind of actions are permitted
  - supervisor: indicates whether page is accessible to only privilged code
  - modified: tracks if page was modified, must be written back if so
  - referenced: keeps track of references, needed to decided which to exict
  - 



---- Memory Notes ----
- virtual memory: program has its own addr space that is broken into pages
- memory management unit: maps virtual addresses onto physical memory addresses
- virtual addresses: program generated addresses that form the virtual address space
- virtual address space: all virtual addresses divided into pages
- pages: fixed size units of virtual addresses
- page frame: corresponding physical memory to a page

- what happens if mmu tries to access unmapped page? page fault, trap in os, write unused page to disk and bring
in needed page
- process of an address fetch w/ virtual memory: 1) program issue adress to access byte in page, 2) mmu checks page table to see if page is mapped to physical frame, 
if mapped, retrieve data, 3) if not mapped, issue page fault bc it needs to load the page into memory 4) select little used page to write to disk, then fetch needed page
5) set old page to unmapped and new page to mapped 6) restart the instruction
- virtual add split into? virtual page number and offset
- what is virtual page number used for? index into page table, if page found, page frame attatched to offset to form physical addr
- purpose of page table? map virtual pages onto page frames



































