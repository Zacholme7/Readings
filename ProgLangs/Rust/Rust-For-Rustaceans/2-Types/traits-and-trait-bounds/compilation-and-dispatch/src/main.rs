// Notes: Compilation and Dispatch
// -----------------------------
// - when you write type/function that is generic over T, youre really telling compiler to make copy of that type/func for each type T
//   - doesnt actually do full copy past, just parts that you use
// - static dispath: for any given copy, the address we are dispatchign to is known statically
// - generic type -> many non generic types is called monomorphization
// - dynamic dispatch enables code to call a trait method on a generic type without knowing what that type is
//   - &dyn makes it so caller must give two pieces of info for that arg. the address of the pattern and the function
//   - in practice, get pointer to memory in vtable
// - combination of a type that implments a trait and its vtable is a trait object
// - to be object-safe, non of traits methods can be generic or use the self type and no static methods
// - dynamic dispatch can cut compile time and improve efficiency, but it prevents compiler from optimizing for the specific types that are used
// - broadly speaking, want to use static dispatch in libraries and dynamic dispath in binaries

// 1) monomorphization
// - helps produce much more efficient code
// - generate for any types we invoke the function with
// - leads to more code in the final binary
// - usually not too much of a cost to generate other functions
//
// example 1
fn strlen(s: impl AsRef<str>) -> usize {
    s.as_ref().len()
}

// can think of the following two as being generated by the compiler due to monoporphization
fn strlen_refstr(s: &str) -> usize {
    s.len()
}

fn strlen_string(s: String) -> usize {
    s.len()
}

// if you ran this function, it would generate a copy of f "inlined" (more of option to) into the function
fn bool_then<T>(b: bool, f: impl FnOnce() -> T) -> Option<T> {
    if b {
        Some(f())
    } else {
        None
    }
}

// now lets get into dispatch...
trait Hello {
    fn hello(&self);
}

impl Hello for &str {
    fn hello(&self) {
        println!("hello {}", self);
    }
}

fn foo() {
    // compiler will determine type of this then look up which methods are available on &str
    // doesnt find any called hello, then looks at the traits and finds it
    "J".hello();
}

fn bar(h: impl Hello) {
    // compiler doesnt actually know the type of h, so what is going to happen here?
    // monomophization will happen and new function will be generated...
    h.hello();
}

// function similar to the following is generated
fn bar_str(h: &str) {
    // now dispatching this is trival, this is statis dispatch
    // at compile the compiler knows what the type is
    h.hello();
}

// what if we dont just want a bunch of copies everywhere?
// what if dont want to care about concrete type and just care it implements some trait?
// dynamic dispatch and DSTs

// Starting off with the Sized trait
// - Sized trait just signals types whos size is known at compile time
// - arguments passed to a function takes up size of the stack, so compiler must know how many
// bytes its going to take up
// - basically always a requirement that a type is sized so the compiler knows how to generate the
// code for it

// can make unsized sized through indirction
// for example, reference
//  - reference is always the same size
//  - box has a size
// - in general, just place it behind some pointer type
pub fn strlen_dyn(s: Box<dyn AsRef<str>>) -> usize {
    s.as_ref().as_ref().len()
}

// trait object: only has the property that it represents a trait
// - only behave as some underlying trait

// how does it know where the hello method is?
// - this is where dynamic dispatch and vtables come into play
// - trait object is a fat pointer
// - ref to trait object stores pointer to the actual concrete implementing type and a pointer to
// the vtable for the referenced trait
// What is a vtable? (virtual dispatch table)
// - dyn Hello, vtable:
//      struct HelloVtable {
//          hello: *mut Fn(*mut ()),
//      }
// - diff vtable is constructued for each concrete type
// &str -> &dyn Hello
// 1) pointer to the str
// 2) HelloVtable {
//  hello: &<str as Hello>::Hello
// }
// - address to vtable goes inside reference
// - indirect via the vtable

fn say_hi(s: &dyn Hello) {
    s.hello() // call???
}

// v tables are built at compile time, but utilized at runtime
// Box<dyn Hello> -> this is a fat pointer right away
//  *mut dyn Hello

/*
 * - This will not work, need pointer to vtable for hei and as_ref
 * - as you add more trait, the size of ref just keeps growing and growing
 * - cant it just generate for combination? in theory yes but it does not currently
 *
 * - could do something like this instead
 * - pub trait HelloAsRef: Hei + AsRef<str> {} and then use that so it only generates one vtable
fn baz(s: &dyn (Hello + AsRef<str>)) {
    s.hello();
    let s = s.as_ref();
    s.len();
}
*/

fn main() {
    let hello_str = "hello";
    let hello_string = String::from("hello");
    // these calls will generate the two functions that we listed above
    strlen(hello_str);
    strlen(hello_string);

    let x = Box::new(String::from("hello"));
    let y: Box<dyn AsRef<str>> = x;
    strlen_dyn(y);
}
